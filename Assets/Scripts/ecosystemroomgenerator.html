<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Room Graph Generator</title>
	<style>
		#outputs { display: flex; flex-wrap: wrap; gap: 12px; }
		.layout { width: 320px; white-space: pre; background: #f8f8f8; padding: 8px; border: 1px solid #ddd; box-sizing: border-box; }
		@media (max-width: 700px) { .layout { width: 100%; } }
	</style>
</head>
<body>
	<h1>Dungeon Ecosystem Generator</h1>
	<div style="display:flex;gap:8px;align-items:center;margin-bottom:8px;flex-wrap:wrap;">
		<button id="generate">Generate Ecosystem</button>
		<label for="room-min">Rooms Min:</label>
		<input id="room-min" type="number" min="2" max="50" placeholder="min" style="width:80px" />
		<label for="room-max">Rooms Max:</label>
		<input id="room-max" type="number" min="2" max="50" placeholder="max" style="width:80px" />
	</div>
	<div id="outputs"></div>

	<script>
		const outputs = document.getElementById('outputs');
		const button = document.getElementById('generate');

		function randInt(min, max) {
			return Math.floor(Math.random() * (max - min + 1)) + min;
		}

		async function loadEcosystem() {
			const res = await fetch('ecosystem.json');
			if (!res.ok) throw new Error('Failed to load ecosystem.json');
			return res.json();
		}

		function pick(arr) {
			return arr[randInt(0, arr.length - 1)];
		}

		function generateGraph(roomCount) {
			const nodeCount = roomCount;
			const nodes = Array.from({ length: nodeCount }, (_, i) => ({
				id: i,
				label: i === 0 ? 'START' : i === nodeCount - 1 ? 'GOAL' : `R${i}`
			}));

			const edges = new Set(); // store undirected edges as "a-b" where a < b

			// backbone path
			for (let i = 0; i < nodeCount - 1; i++) edges.add(`${i}-${i + 1}`);

			// compute degrees from backbone
			const degree = new Array(nodeCount).fill(0);
			for (const e of edges) {
				const [a, b] = e.split('-').map(Number);
				degree[a]++; degree[b]++;
			}

			// add up to 3 extra edges, but never touch GOAL (nodeCount-1)
			let extra = randInt(0, 3), added = 0, tries = 0;
			while (added < extra && tries < 1000) {
				tries++;
				const a = randInt(0, nodeCount - 2);
				const b = randInt(0, nodeCount - 2);
				if (a === b) continue;
				const x = Math.min(a, b), y = Math.max(a, b);
				if (edges.has(`${x}-${y}`)) continue;
				// enforce max 3 edges per node
				if (degree[x] >= 3 || degree[y] >= 3) continue;
				// prevent direct START-GOAL connection (defensive)
				if ((x === 0 && y === nodeCount - 1) || (x === nodeCount - 1 && y === 0)) continue;
				edges.add(`${x}-${y}`);
				degree[x]++; degree[y]++;
				added++;
			}

			const adjacency = new Map();
			for (const n of nodes) adjacency.set(n.id, new Set());
			for (const e of edges) {
				const [a, b] = e.split('-').map(Number);
				adjacency.get(a).add(b);
				adjacency.get(b).add(a);
			}

			return { nodes, adjacency };
		}

		function assignRooms(graph, ecosystem) {
			const biomeNames = ecosystem.biomes.map(b => b.name);
			const creatures = ecosystem.creatures;
			const biome = pick(biomeNames);
			const options = creatures.filter(c =>
				c.biomes.includes(biome) && c.population_range[1] > 0
			);

			const rooms = graph.nodes.map(node => {
				const count = Math.min(3, options.length);
				const selectedCount = count > 0 ? randInt(1, count) : 0;
				const selected = [];
				const pool = [...options];
				for (let i = 0; i < selectedCount; i++) {
					const idx = randInt(0, pool.length - 1);
					selected.push(pool.splice(idx, 1)[0]);
				}
				const occupants = selected
					.map(c => {
						const minPop = Math.max(1, c.population_range[0]);
						const pop = randInt(minPop, c.population_range[1]);
						return `${c.name} x${pop}`;
					})
					.filter(Boolean);
				return { ...node, biome, occupants };
			});

			return { biome, rooms };
		}

		function renderRooms(graph, biome, rooms) {
			const lines = ['Rooms and Connections:', `Biome: ${biome}`];
			for (const room of rooms) {
				const neighbors = [...graph.adjacency.get(room.id)]
					.map(id => rooms[id].label)
					.sort();
				lines.push('');
				lines.push(`${room.label}`);
				lines.push(`  Creatures: ${room.occupants.join(', ') || 'None'}`);
				lines.push(`  Adjacent: ${neighbors.join(', ')}`);
			}
			return lines.join('\n');
		}

		async function generateAndRender(count = 5) {
			outputs.innerHTML = '';
			try {
				const ecosystem = await loadEcosystem();
				for (let i = 0; i < count; i++) {
					const minVal = parseInt(document.getElementById('room-min').value, 10);
					const maxVal = parseInt(document.getElementById('room-max').value, 10);
					let roomCount;
					if (Number.isFinite(minVal) && Number.isFinite(maxVal)) {
						let min = Math.max(2, Math.floor(minVal));
						let max = Math.max(2, Math.floor(maxVal));
						if (min > max) { const t = min; min = max; max = t; }
						roomCount = randInt(min, max);
					} else {
						roomCount = randInt(8, 14);
					}
					const graph = generateGraph(roomCount);
					const { biome, rooms } = assignRooms(graph, ecosystem);
					const text = `Layout ${i + 1}:\n${renderRooms(graph, biome, rooms)}`;
					const pre = document.createElement('pre');
					pre.className = 'layout';
					pre.innerText = text;
					outputs.appendChild(pre);
				}
			} catch (err) {
				const pre = document.createElement('pre');
				pre.className = 'layout';
				pre.innerText = `Error: ${err.message}`;
				outputs.appendChild(pre);
			}
		}

		button.addEventListener('click', () => generateAndRender(5));
		generateAndRender(5);
	</script>
</body>
</html>
